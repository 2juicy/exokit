<!doctype html>
<html>
  <head>
    <style>
      body {
        margin: 0;
      }
      #blocker {
				position: absolute;
				width: 100%;
				height: 100%;
				background-color: rgba(0,0,0,0.5);
			}
			#instructions {
				width: 100%;
				height: 100%;
				display: -webkit-box;
				display: -moz-box;
				display: box;
				-webkit-box-orient: horizontal;
				-moz-box-orient: horizontal;
				box-orient: horizontal;
				-webkit-box-pack: center;
				-moz-box-pack: center;
				box-pack: center;
				-webkit-box-align: center;
				-moz-box-align: center;
				box-align: center;
				color: #ffffff;
				text-align: center;
				cursor: pointer;
			}
    </style>
  </head>
  <body>
    <div id=blocker>

			<div id=instructions>
				<span style="font-size:40px">Click to play</span>
				<br />
				(W, A, S, D = Move, SPACE = Jump, MOUSE = Look around)
			</div>

		</div>
    <script src="three.js"></script>
    <script src="PointerLockControls.js"></script>
<script>
(() => {
let scene, camera, clock, controls;

var controlsEnabled = false;
var moveForward = false;
var moveBackward = false;
var moveLeft = false;
var moveRight = false;
var canJump = false;
var prevTime = performance.now();
var velocity = new THREE.Vector3();
var direction = new THREE.Vector3();
var vertex = new THREE.Vector3();
var color = new THREE.Color();

function init() {
  scene = new THREE.Scene();
  scene.matrixAutoUpdate = false;
  // scene.background = new THREE.Color(0x3B3961);

  camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
  // camera.position.set(0, 1, 0);
  // camera.lookAt(new THREE.Vector3(0, 0, -1));
  scene.add(camera);

  const ambientLight = new THREE.AmbientLight(0x808080);
  scene.add(ambientLight);

  const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1);
  directionalLight.position.set(1, 1, 1);
  scene.add(directionalLight);

  (() => {
    const geometry = new THREE.BoxBufferGeometry(0.1, 1, 0.1);
    const material = new THREE.MeshPhongMaterial({
      color: 0xE91E63,
    });
    const mesh = new THREE.Mesh(geometry, material);
    // mesh.position.y = 0.5;
    mesh.position.z = -1;
    mesh.updateMatrix();
    mesh.updateMatrixWorld();
    mesh.frustumCuled = false;
    scene.add(mesh);
  })();

  (() => {
    var element = document.body;
    var pointerlockchange = function ( event ) {
      if ( document.pointerLockElement === element /* || document.mozPointerLockElement === element || document.webkitPointerLockElement === element */) {
        controlsEnabled = true;
        controls.enabled = true;
        blocker.style.display = 'none';
      } else {
        controls.enabled = false;
        blocker.style.display = 'block';
        instructions.style.display = '';
      }
    };
    var pointerlockerror = function ( event ) {
      instructions.style.display = '';
    };
    // Hook pointer lock state change events
    document.addEventListener( 'pointerlockchange', pointerlockchange, false );
    document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
    document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );
    document.addEventListener( 'pointerlockerror', pointerlockerror, false );
    document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
    document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );
    instructions.addEventListener( 'click', function ( event ) {
      instructions.style.display = 'none';
      // Ask the browser to lock the pointer
      // element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
      element.requestPointerLock();
    }, false );
  })();

  controls = new THREE.PointerLockControls(camera);
	scene.add(controls.getObject());

  var onKeyDown = function ( event ) {
    switch ( event.keyCode ) {
      case 38: // up
      case 87: // w
        moveForward = true;
        break;
      case 37: // left
      case 65: // a
        moveLeft = true; break;
      case 40: // down
      case 83: // s
        moveBackward = true;
        break;
      case 39: // right
      case 68: // d
        moveRight = true;
        break;
      case 32: // space
        if ( canJump === true ) velocity.y += 350;
        canJump = false;
        break;
    }
  };
  var onKeyUp = function ( event ) {
    switch( event.keyCode ) {
      case 38: // up
      case 87: // w
        moveForward = false;
        break;
      case 37: // left
      case 65: // a
        moveLeft = false;
        break;
      case 40: // down
      case 83: // s
        moveBackward = false;
        break;
      case 39: // right
      case 68: // d
        moveRight = false;
        break;
    }
  };
  document.addEventListener( 'keydown', onKeyDown, false );
  document.addEventListener( 'keyup', onKeyUp, false );

  renderer = new THREE.WebGLRenderer({
    antialias: true,
  });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  renderer.setAnimationLoop(animate);
}

function animate() {
  if (controlsEnabled) {
    var time = performance.now();
    var delta = ( time - prevTime ) / 1000;
    velocity.x -= velocity.x * 10.0 * delta;
    velocity.z -= velocity.z * 10.0 * delta;
    velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass
    direction.z = Number( moveForward ) - Number( moveBackward );
    direction.x = Number( moveLeft ) - Number( moveRight );
    direction.normalize(); // this ensures consistent movements in all directions
    if ( moveForward || moveBackward ) velocity.z -= direction.z * 20.0 * delta;
    if ( moveLeft || moveRight ) velocity.x -= direction.x * 20.0 * delta;
    controls.getObject().translateX( velocity.x * delta );
    controls.getObject().translateY( velocity.y * delta );
    controls.getObject().translateZ( velocity.z * delta );
    if ( controls.getObject().position.y < 0 ) {
      velocity.y = 0;
      controls.getObject().position.y = 0;
    }
    prevTime = time;
  }
  renderer.render(scene, camera);
}

init();

// connection

const terrainMeshes = [];
const terrainMaterial = new THREE.MeshPhongMaterial({
  color: 0x666666,
});
const _getTerrainMesh = meshId => {
  let terrainMesh = terrainMeshes.find(terrainMesh => terrainMesh.meshId === meshId);
  if (!terrainMesh) {
    terrainMesh = _makeTerrainMesh(meshId);
    terrainMeshes.push(terrainMesh);
    scene.add(terrainMesh);
  }
  return terrainMesh;
};
const fakeArrayBuffer = new ArrayBuffer(3 * 4);
const fakeFloat32Array = new Float32Array(fakeArrayBuffer, 0, 3);
const fakeUint16Array = new Uint16Array(fakeArrayBuffer, 0, 3);
const _makeTerrainMesh = meshId => {
  const geometry = new THREE.BufferGeometry();
  const gl = renderer.getContext();
  const attributes = renderer.getAttributes();

  geometry.addAttribute('position', new THREE.BufferAttribute(fakeFloat32Array, 3));
  attributes.update(geometry.attributes.position, gl.ARRAY_BUFFER);
  geometry.addAttribute('normal', new THREE.BufferAttribute(fakeFloat32Array, 3));
  attributes.update(geometry.attributes.normal, gl.ARRAY_BUFFER);
  geometry.setIndex(new THREE.BufferAttribute(fakeUint16Array, 1));
  attributes.update(geometry.index, gl.ELEMENT_ARRAY_BUFFER);

  const material = terrainMaterial;

  const mesh = new THREE.Mesh(geometry, material);
  mesh.meshId = meshId;
  mesh.frustumCulled = false;
  return mesh;
};
const _loadTerrainMesh = (terrainMesh, {positionArray, positionCount, normalArray, normalCount, indexArray, count}) => {
  const {geometry} = terrainMesh;

  geometry.addAttribute('position', new THREE.BufferAttribute(positionArray, 3));
  geometry.addAttribute('normal', new THREE.BufferAttribute(normalArray, 3));
  geometry.setIndex(new THREE.BufferAttribute(indexArray, 1));
};
const _removeTerrainMesh = terrainMesh => {
  scene.remove(terrainMesh);
  terrainMesh.geometry.dispose();
};

const playerMeshes = [];
const playerGeometry = new THREE.CylinderBufferGeometry(0.1, 0.1, 0.2, 32, 1)
  .applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.2/2, 0))
  .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(
    new THREE.Quaternion().setFromUnitVectors(
      new THREE.Vector3(0, 1, 0),
      new THREE.Vector3(0, 0, -1)
    )
  ));
const playerMaterial = new THREE.MeshPhongMaterial({
  color: 0x2196f3,
});
const _getPlayerMesh = meshId => {
  let playerMesh = playerMeshes.find(playerMesh => playerMesh.meshId === meshId);
  if (!playerMesh) {
    playerMesh = _makePlayerMesh(meshId);
    playerMeshes.push(playerMesh);
    scene.add(playerMesh);
  }
  return playerMesh;
};
const _makePlayerMesh = meshId => {
  const mesh = new THREE.Mesh(playerGeometry, playerMaterial);
  mesh.meshId = meshId;
  mesh.frustumCulled = false;
  return mesh;
};
const _loadPlayerMesh = (playerMesh, {position, rotation}) => {
  playerMesh.position.fromArray(position);
  playerMesh.quaternion.fromArray(rotation);
  playerMesh.updateMatrix();
  playerMesh.updateMatrixWorld();
};
const _removePlayerMesh = playerMesh => {
  scene.remove(playerMesh);
};

const ws = new WebSocket((window.location.protocol === 'https:' ? 'wss' : 'ws') + '://' + window.location.host + '/');
ws.binaryType = 'arraybuffer';
ws.onopen = () => {
  let running = false;
  const queue = [];
  const _handleData = data => {
    if (!running) {
      running = true;

      const message = JSON.parse(data);
      const {method} = message;

      switch (method) {
        case 'mesh': {
          const {updates} = message;

          Promise.all(updates.map(update => {
            const {id, type} = update;

            if (type === 'new' || type === 'update') {
              return fetch('/mesh/' + id)
                .then(res => res.ok ? res.arrayBuffer() : Promise.resolve(null))
                .then(arrayBuffer => {
                  if (arrayBuffer) {
                    let i = 0;
                    const positionCount = new Uint32Array(arrayBuffer, i, 1)[0];
                    i += Uint32Array.BYTES_PER_ELEMENT;
                    const positionArray = new Float32Array(arrayBuffer, i, positionCount);
                    i += Float32Array.BYTES_PER_ELEMENT * positionCount;

                    const normalCount = new Uint32Array(arrayBuffer, i, 1)[0];
                    i += Uint32Array.BYTES_PER_ELEMENT;
                    const normalArray = new Float32Array(arrayBuffer, i, normalCount);
                    i += Float32Array.BYTES_PER_ELEMENT * normalCount;

                    const count = new Uint32Array(arrayBuffer, i, 1)[0];
                    i += Uint32Array.BYTES_PER_ELEMENT;
                    const indexArray = new Uint16Array(arrayBuffer, i, count);
                    i += Uint16Array.BYTES_PER_ELEMENT * count;

                    const update = {
                      positionArray,
                      positionCount,
                      normalArray,
                      normalCount,
                      indexArray,
                      count,
                    };
                    _loadTerrainMesh(_getTerrainMesh(id), update);
                  }
                });
            } else {
              const index = terrainMeshes.findIndex(terrainMesh => terrainMesh.meshId === id);
              if (index !== -1) {
                const terrainMesh = terrainMeshes[index];
                _removeTerrainMesh(terrainMesh);
                terrainMeshes.splice(index, 1);
              }
            }
          }))
            .catch(err => {
              console.warn(err.stack);
            })
            .finally(() => {
              running = false;

              if (queue.length > 0) {
                _handleData(queue.shift());
              }
            });
          break;
        }
        case 'transform': {
          const {players} = message;

          for (let i = 0; i < players.length; i++) {
            const player = players[i];
            const {type, id} = player;

            if (type === 'update') {
              _loadPlayerMesh(_getPlayerMesh(id), player);
            } else {
              const index = playerMeshes.findIndex(playerMesh => playerMesh.meshId === id);
              if (index !== -1) {
                const playerMesh = playerMeshes[index];
                _removePlayerMesh(playerMesh);
                playerMeshes.splice(index, 1);
              }
            }
          }

          break;
        }
      }
    } else {
      queue.push(data);
    }
  };
  ws.onmessage = m => {
    _handleData(m.data);
  };

  const localVector = new THREE.Vector3();
  const localVector2 = new THREE.Vector3();
  const localQuaternion = new THREE.Quaternion();
  const interval = setInterval(() => {
    camera.matrixWorld.decompose(localVector, localQuaternion. localVector2);
    const updateSpec = {
      method: 'transform',
      position: localVector.toArray(),
      rotation: localQuaternion.toArray(),
    };
    const updateSpecString = JSON.stringify(updateSpec);
    ws.send(updateSpecString);
  }, 1000 / 30);

  ws.onclose = () => {
    clearInterval(interval);
  };
};
})();
</script>
  </body>
</html>
