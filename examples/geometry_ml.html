<html>
  <head>
    <style>
      body {
        margin: 0;
      }
    </style>
  </head>
  <body>
  <script src="three.js"></script>
  <script>
    let container, scene, camera, display, controllerMeshes;
    let mesher = null, connections = [], terrainMeshData = {};

    const controllerGeometry = new THREE.BoxBufferGeometry(0.1, 0.2, 0.01);
    const controllerMaterial = new THREE.MeshPhongMaterial({
      color: 0x4caf50,
    });
    const _makeControllerMesh = (x = 0, y = 0, z = 0, qx = 0, qy = 0, qz = 0, qw = 1) => {
      const mesh = new THREE.Mesh(controllerGeometry, controllerMaterial);
      mesh.position.set(x, y, z);
      mesh.quaternion.set(qx, qy, qz, qw);
      // mesh.matrix.compose(mesh.position, mesh.quaternion, mesh.scale);
      mesh.updateMatrix();
      mesh.updateMatrixWorld();
      mesh.matrixAutoUpdate = false;
      mesh.frustumCulled = false;
      return mesh;
    };
    const playerGeometry = new THREE.CylinderBufferGeometry(0.1, 0.1, 0.2, 32, 1)
      .applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.2/2, 0))
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(
        new THREE.Quaternion().setFromUnitVectors(
          new THREE.Vector3(0, 1, 0),
          new THREE.Vector3(0, 0, -1)
        )
      ));
    const playerMaterial = new THREE.MeshPhongMaterial({
      color: 0x2196f3,
    });
    const _makePlayerMesh = () => {
      const mesh = new THREE.Mesh(playerGeometry, playerMaterial);
      // mesh.matrix.compose(mesh.position, mesh.quaternion, mesh.scale);
      // mesh.updateMatrix();
      // mesh.updateMatrixWorld();
      mesh.matrixAutoUpdate = false;
      mesh.frustumCulled = false;
      return mesh;
    };

    function init() {
      container = document.createElement('div');
      document.body.appendChild(container);

      scene = new THREE.Scene();
      scene.matrixAutoUpdate = false;
      // scene.background = new THREE.Color(0x3B3961);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      // camera.position.set(0, 1, 0);
      camera.lookAt(new THREE.Vector3());
      scene.add(camera);

      const ambientLight = new THREE.AmbientLight(0x808080);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1);
      directionalLight.position.set(1, 1, 1);
      scene.add(directionalLight);

      /* (() => {
        const geometry = new THREE.BoxBufferGeometry(0.1, 1, 0.1);
        const material = new THREE.MeshPhongMaterial({
          color: 0xE91E63,
        });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.y = 0.5;
        // mesh.position.z = -1;
        mesh.frustumCuled = false;
        scene.add(mesh);
      })();
      (() => {
        const geometry = new THREE.BoxBufferGeometry(0.1, 0.1, 0.1);
        const material = new THREE.MeshPhongMaterial({
          color: 0x4CAF50,
        });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.y = 1 + 0.1;
        // mesh.position.z = -1;
        mesh.frustumCulled = false;
        scene.add(mesh);
      })(); */

      controllerMeshes = [
        _makeControllerMesh(-0.1),
        _makeControllerMesh(0.1),
      ];
      controllerMeshes.forEach(controllerMesh => {
        scene.add(controllerMesh);
      });

      const terrainMeshes = [];
      const terrainMaterial = new THREE.MeshPhongMaterial({
        color: 0x666666,
      });
      const _getTerrainMesh = meshId => {
        let terrainMesh = terrainMeshes.find(terrainMesh => terrainMesh.meshId === meshId);
        if (!terrainMesh) {
          terrainMesh = _makeTerrainMesh(meshId);
          terrainMeshes.push(terrainMesh);
          scene.add(terrainMesh);
        }
        return terrainMesh;
      };
      const fakeArrayBuffer = new ArrayBuffer(3 * 4);
      const fakeFloat32Array = new Float32Array(fakeArrayBuffer, 0, 3);
      const fakeUint16Array = new Uint16Array(fakeArrayBuffer, 0, 3);
      const _makeTerrainMesh = meshId => {
        const geometry = new THREE.BufferGeometry();
        const gl = renderer.getContext();
        const attributes = renderer.getAttributes();

        geometry.addAttribute('position', new THREE.BufferAttribute(fakeFloat32Array, 3));
        attributes.update(geometry.attributes.position, gl.ARRAY_BUFFER);
        geometry.addAttribute('normal', new THREE.BufferAttribute(fakeFloat32Array, 3));
        attributes.update(geometry.attributes.normal, gl.ARRAY_BUFFER);
        geometry.setIndex(new THREE.BufferAttribute(fakeUint16Array, 1));
        attributes.update(geometry.index, gl.ELEMENT_ARRAY_BUFFER);

        const material = terrainMaterial;

        const mesh = new THREE.Mesh(geometry, material);
        mesh.meshId = meshId;
        mesh.frustumCulled = false;
        return mesh;
      };
      const _loadTerrainMesh = (terrainMesh, {positionBuffer, positionArray, positionCount, normalBuffer, normalArray, normalCount, indexBuffer, indexArray, count}) => {
        const {geometry} = terrainMesh;
        const attributes = renderer.getAttributes();

        attributes.get(geometry.attributes.position).buffer = positionBuffer;
        geometry.attributes.position.count = positionCount / 3;

        attributes.get(geometry.attributes.normal).buffer = normalBuffer;
        geometry.attributes.normal.count = normalCount / 3;

        attributes.get(geometry.index).buffer = indexBuffer;
        geometry.index.count = count / 1;
      };
      const _removeTerrainMesh = terrainMesh => {
        scene.remove(terrainMesh);
        terrainMesh.geometry.dispose();
      };
      const _clearTerrainMeshes = () => {
        for (let i = 0; i < terrainMeshes.length; i++) {
          _removeTerrainMesh(terrainMeshes[i]);
        }
        terrainMeshes.length = 0;
      };
      const _loadTerrainData = ({id, positionArray, positionCount, normalArray, normalCount, indexArray, count}) => {
        const dataArray = new ArrayBuffer(
          Uint32Array.BYTES_PER_ELEMENT + positionCount * Float32Array.BYTES_PER_ELEMENT +
          Uint32Array.BYTES_PER_ELEMENT + normalCount * Float32Array.BYTES_PER_ELEMENT +
          Uint32Array.BYTES_PER_ELEMENT + count * Uint16Array.BYTES_PER_ELEMENT
        );

        let i = 0;
        new Uint32Array(dataArray, i, 1)[0] = positionCount;
        i += Uint32Array.BYTES_PER_ELEMENT;
        new Float32Array(dataArray, i, positionCount).set(positionArray);
        i += Float32Array.BYTES_PER_ELEMENT * positionCount;

        new Uint32Array(dataArray, i, 1)[0] = normalCount;
        i += Uint32Array.BYTES_PER_ELEMENT;
        new Float32Array(dataArray, i, normalCount).set(normalArray);
        i += Float32Array.BYTES_PER_ELEMENT * normalCount;

        new Uint32Array(dataArray, i, 1)[0] = count;
        i += Uint32Array.BYTES_PER_ELEMENT;
        new Uint16Array(dataArray, i, count).set(indexArray);
        i += Uint16Array.BYTES_PER_ELEMENT * count;

        terrainMeshData[id] = dataArray;
      };
      const _removeTerrainData = id => {
        terrainMeshData[id] = null;
      };
      const _onMesh = updates => {
        for (let i = 0; i < updates.length; i++) {
          const update = updates[i];
          const {id, type} = update;

          if (type === 'new' || type === 'update') {
            _loadTerrainMesh(_getTerrainMesh(id), update);
            _loadTerrainData(update);
          } else {
            const index = terrainMeshes.findIndex(terrainMesh => terrainMesh.meshId === id);
            if (index !== -1) {
              const terrainMesh = terrainMeshes[index];
              _removeTerrainMesh(terrainMesh);
              terrainMeshes.splice(index, 1);

              _removeTerrainData(id);
            }
          }
        }

        if (connections.length > 0) {
          const updateSpec = {
            method: 'mesh',
            updates: updates.map(({id, type}) => ({id, type})),
          };
          const updateSpecString = JSON.stringify(updateSpec);

          for (let i = 0; i < connections.length; i++) {
            const c = connections[i];
            c.send(updateSpecString);
          }
        }
      };

      let enabled = false;
      const _enable = () => {
        mesher = window.browser.magicleap.RequestMeshing();
        mesher.onmesh = _onMesh;

        enabled = true;
      };
      const _disable = () => {
        mesher.destroy();
        mesher = null;
        _clearTerrainMeshes();

        enabled = false;
      };
      _enable();
      window.addEventListener('keydown', e => {
        if (e.keyCode === 13) { // enter
          if (enabled) {
            _disable();
          } else {
            _enable();
          }
        }
      });

      const interval = setInterval(() => {
        if (connections.length > 0) {
          const updateSpec = {
            method: 'transform',
            players: [
              {
                id: 'host',
                type: 'update',
                position: camera.position.toArray(),
                rotation: camera.quaternion.toArray(),
              },
            ],
          };
          const updateSpecString = JSON.stringify(updateSpec);

          for (let i = 0; i < connections.length; i++) {
            const c = connections[i];
            c.send(updateSpecString);
          }
        }
      }, 1000 / 30);

      renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);

      // window.browser.magicleap.RequestDepthPopulation(true);
      // renderer.autoClear = false;

      container.appendChild(renderer.domElement);

      renderer.setAnimationLoop(animate);
    }

    function animate(time, frame) {
      if (renderer.vr.enabled) {
        const inputSources = display.session.getInputSources();

        for (let i = 0; i < inputSources.length; i++) {
          const inputSource = inputSources[i];
          const pose = frame.getInputPose(inputSource);

          const controllerMesh = controllerMeshes[i];
          controllerMesh.matrix.fromArray(pose.pointerMatrix);
          controllerMesh.updateMatrixWorld(true);
        }
      }

      renderer.render(scene, renderer.vr.enabled ? renderer.vr.getCamera(camera) : camera);
    }

    init();

    (async () => {
      console.log('request device');
      display = await navigator.xr.requestDevice();
      console.log('request session');
      const session = await display.requestSession({
        exclusive: true,
      });
      display.session = session;

      session.onselect = e => {
        const controllerIndex = e.inputSource.handedness === 'left' ? 0 : 1;
        const controllerMesh = controllerMeshes[controllerIndex];
        controllerMesh.matrixWorld.decompose(controllerMesh.position, controllerMesh.quaternion, controllerMesh.scale);

        const objectMesh = _makeControllerMesh(
          controllerMesh.position.x, controllerMesh.position.y, controllerMesh.position.z,
          controllerMesh.quaternion.x, controllerMesh.quaternion.y, controllerMesh.quaternion.z, controllerMesh.quaternion.w,
        );
        scene.add(objectMesh);
      };

      // console.log('request first frame');
      session.requestAnimationFrame((timestamp, frame) => {
        renderer.vr.setSession(session, {
          frameOfReferenceType: 'stage',
        });

        const viewport = session.baseLayer.getViewport(frame.views[0]);
        const width = viewport.width;
        const height = viewport.height;

        renderer.setSize(width * 2, height);

        renderer.setAnimationLoop(null);

        renderer.vr.enabled = true;
        renderer.vr.setDevice(display);
        renderer.vr.setAnimationLoop(animate);

        console.log('running!');
      });
    })();

    (() => {
      const server = window.browser.http.createServer((req, res) => {
        console.log('got request', req.url);

        let match;
        if (req.url === '/') {
          res.statusCode = 302;
          res.setHeader('Location', '/examples/geometry_client.html');
          res.end();
        } else if (match = req.url.match(/\.(html|js)$/)) {
          fetch('file:///package' + req.url)
            .then(proxyRes => {
              if (proxyRes.ok) {
                return proxyRes.arrayBuffer()
                  .then(arrayBuffer => {
                    const type = (() => {
                      switch (match[1]) {
                        case 'html': return 'text/html';
                        case 'js': return 'application/javascript';
                        default: return 'text/plain';
                      }
                    })();
                    res.setHeader('Content-Type', type);

                    const buffer = Buffer.from(arrayBuffer);
                    res.end(buffer);
                  });
              } else {
                res.statusCode = proxyRes.status;
                res.end();
                return null;
              }
            })
            .catch(err => {
              console.warn(err.stack);
              res.statusCode = 500;
              res.end();
            });
        } else if (match = req.url.match(/^\/mesh\/(.+)$/)) {
          const meshId = match[1];
          let tmd = terrainMeshData[meshId];
          if (tmd) {
            tmd = Buffer.from(tmd);
            res.setHeader('Content-Type', 'application/octet-stream');
            res.end(tmd);
          } else {
            res.statusCode = 404;
            res.end();
          }
        } else {
          res.statusCode = 404;
          res.end();
        }
      });

      const wss = new window.browser.ws.Server({
        server,
      });
      wss.on('connection', c => {
        console.log('open connection');

        c.playerId = Math.random().toString(36).substring(7);
        c.mesh = _makePlayerMesh();
        scene.add(c.mesh);

        const ids = Object.keys(terrainMeshData).filter(id => !!terrainMeshData[id]);
        const updateSpec = ids.map(id => ({
          type: 'new',
          id,
        }));
        const updateSpecString = JSON.stringify(updateSpec);
        c.send(updateSpecString);

        connections.push(c);

        c.on('message', data => {
          const message = JSON.parse(data);
          const {method} = message;

          switch (method) {
            case 'transform': {
              const {position, rotation} = message;
              c.mesh.position.fromArray(position);
              c.mesh.quaternion.fromArray(rotation);
              c.mesh.updateMatrix();
              c.mesh.updateMatrixWorld();
              break;
            }
            default: {
              console.warn('unknown client method', method);
              break;
            }
          }
        });
        c.on('close', () => {
          console.log('close connection');

          scene.remove(c.mesh);
          c.mesh.geometry.dispose();

          connections.splice(connections.indexOf(c), 1);
        });
      });

      server.listen(7999, '0.0.0.0', () => {
        console.log('listening');
      });
      server.on('error', err => {
        console.warn('server error', err.stack);
      });
    })();
  </script>
  </body>
</html>
