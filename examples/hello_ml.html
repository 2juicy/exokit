<html>
  <head>
    <style>
      body {
        margin: 0;
      }
    </style>
  </head>
  <body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/95/three.js"></script>
  <script>
    function init() {
      container = document.createElement('div');
      document.body.appendChild(container);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      // camera.position.set(0, 1, 0);
      camera.lookAt(new THREE.Vector3());

      scene = new THREE.Scene();
      scene.matrixAutoUpdate = false;
      // scene.background = new THREE.Color(0x3B3961);

      const ambientLight = new THREE.AmbientLight(0x808080);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1);
      directionalLight.position.set(1, 1, 1);
      scene.add(directionalLight);

      (() => {
        const geometry = new THREE.BoxBufferGeometry(0.1, 1, 0.1);
        const material = new THREE.MeshPhongMaterial({
          color: 0xE91E63,
        });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.y = 0.5;
        // mesh.position.z = -1;
        mesh.frustumCuled = false;
        scene.add(mesh);
      })();
      (() => {
        const geometry = new THREE.BoxBufferGeometry(0.1, 0.1, 0.1);
        const material = new THREE.MeshPhongMaterial({
          color: 0x4CAF50,
        });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.y = 1 + 0.1;
        // mesh.position.z = -1;
        mesh.frustumCulled = false;
        scene.add(mesh);
      })();

      const terrainMeshes = {};
      /* const terrainMaterial = new THREE.ShaderMaterial({
        vertexShader: `\
          void main() {
            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
            vec4 position = projectionMatrix * mvPosition;
            gl_Position = position;
          }
        `,
        fragmentShader: `\
          void main() {
            float originalZ = gl_FragCoord.z / gl_FragCoord.w;
            float factor = max((3.0 - originalZ) / 3.0, 0.1);
            // float depthDangerFactor = 0.95;
            // if (factor > depthDangerFactor) {
              // gl_FragColor.rgba = vec4(1.0, 0.0, 0.0, 1.0);
            // } else {
              gl_FragColor.rgba = vec4(vec3(factor), 1.0);
            // }
          }
        `,
      }); */
      const terrainMaterial = new THREE.MeshPhongMaterial({
        color: 0x666666,
      });
      const _getTerrainMesh = id => {
        let terrainMesh = terrainMeshes[id];
        if (!terrainMesh) {
          terrainMesh = _makeTerrainMesh();
          terrainMeshes[id] = terrainMesh;
          scene.add(terrainMesh);
        }
        return terrainMesh;
      };
      const _makeTerrainMesh = () => {
        const geometry = new THREE.BufferGeometry();
        const positions = Float32Array.from([
          0, 0, 0,
          0, 1, 0,
          1, 1, 0,
        ]);
        geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
        const normals = Float32Array.from([
          0, 0, 1,
          0, 0, 1,
          0, 0, 1,
        ]);
        geometry.addAttribute('normal', new THREE.BufferAttribute(normals, 3));
        const indices = Uint32Array.from([
          0, 1, 2,
        ]);
        geometry.setIndex(new THREE.BufferAttribute(indices, 1));
        const material = terrainMaterial;
        const mesh = new THREE.Mesh(geometry, material);
        mesh.frustumCulled = false;
        return mesh;
      };
      const _loadTerrainMesh = (terrainMesh, {positions, normals, indices}) => {
        // let updated = false;
        // if (positions && terrainMesh.geometry.attributes.position.array !== positions) {
          // console.log('update positions', positions.length);
          const newPositions = new Float32Array(positions.length);
          newPositions.set(positions);
          terrainMesh.geometry.addAttribute('position', new THREE.BufferAttribute(newPositions, 3));
          // updated = true;
        // }
        // if (normals && terrainMesh.geometry.attributes.normal.array !== normals) {
          // console.log('update normals', normals.length, normals.slice(0, 9), normals instanceof Float32Array);
          const newNormals = new Float32Array(normals.length);
          newNormals.set(normals);
          terrainMesh.geometry.addAttribute('normal', new THREE.BufferAttribute(newNormals, 3));
          // updated = true;
        // }
        // if (indices && terrainMesh.geometry.index.array !== indices) {
          // console.log('update indices', indices.length, indices.slice(0, 3), indices instanceof Uint32Array);
          const newIndices = new Uint16Array(indices.length);
          newIndices.set(indices);
          terrainMesh.geometry.setIndex(new THREE.BufferAttribute(newIndices, 1));
          // updated = true;
        // }
        // return updated;
      };
      // const terrainMesh = _makeTerrainMesh();
      // scene.add(terrainMesh);

      const _onHand = hands => {
        for (let i = 0; i < hands.length; i++) {
          const hand = hands[i];
          if (hand) {
            console.log('got hand', hand.hand, hand.center.join(','), hand.gesture);
          }
        }
      };
      window.browser.nativeMl.RequestHand(_onHand);

      const _onMesh = updates => {
        for (let i = 0; i < updates.length; i++) {
          const update = updates[i];
          const terrainMesh = _getTerrainMesh(update.id);
          _loadTerrainMesh(terrainMesh, update);
        }
      };
      window.browser.nativeMl.RequestMesh(_onMesh);

      renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      container.appendChild(renderer.domElement);

      renderer.setAnimationLoop(animate);
    }

    function animate() {
      renderer.render(scene, renderer.vr.enabled ? renderer.vr.getCamera(camera) : camera);
    }

    init();

    // renderer.setAnimationLoop(animate);
    (async () => {
      console.log('request device');
      const display = await navigator.xr.requestDevice();
      console.log('request session');
      const session = await display.requestSession({
        exclusive: true,
      });
      display.session = session;

      console.log('request first frame');
      session.requestAnimationFrame((timestamp, frame) => {
        renderer.vr.setSession(session, {
          frameOfReferenceType: 'stage',
        });

        const viewport = session.baseLayer.getViewport(frame.views[0]);
        const width = viewport.width;
        const height = viewport.height;

        renderer.setSize(width * 2, height);

        renderer.setAnimationLoop(null);

        renderer.vr.enabled = true;
        renderer.vr.setDevice(display);
        renderer.vr.setAnimationLoop(animate);

        console.log('running!');
      });
    })();

    (() => {
      const framesData = [];

      const server = window.browser.http.createServer((req, res) => {
        console.log('got request', req.url);

        let match;
        if (req.url === '/') {
          res.setHeader('Content-Type', 'text/html');
          const lt = String.fromCodePoint(60);
          const gt = String.fromCodePoint(62);
          res.end(`\
            ${lt}!doctype html${gt}
            ${lt}html${gt}
              ${lt}head${gt}${lt}/head${gt}
              ${lt}body${gt}
                ${lt}canvas id=canvas /${gt}
                ${lt}pre${gt}${lt}code${gt}
(() => {
  const width = 1280;
  const height = 1024;

  const canvas = document.getElementById('canvas');
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext('2d');

  const ws = new WebSocket((window.location.protocol === 'https:' ? 'wss' : 'ws') + '://' + window.location.host + '/');
  ws.binaryType = 'arraybuffer';
  ws.onopen = () => {
    console.log('connected');
  };

  let running = false;
  let pendingData = null;
  const _handleData = data => {
    if (!running) {
      running = true;

      const datas = JSON.parse(data);
      Promise.all(datas.map(data =>
        fetch('/frame/' + data.index)
          .then(res => res.arrayBuffer())
          .then(arrayBuffer => ({
            data,
            arrayBuffer,
          }))
      ))
        .then(results => {
          const result = results[0];
          const {data, arrayBuffer} = result;
          const {width, height} = data;

          const imageData = ctx.createImageData(width, height);
          imageData.data.set(new Uint8ClampedArray(arrayBuffer).slice(0, imageData.data.byteLength));
          ctx.putImageData(imageData, 0, 0);
        })
        .then(() => {
          running = false;
          _next();
        })
        .catch(err => {
          console.warn(err.stack);

          running = false;
          _next();
        });
    } else {
      pendingData = data;
    }
  };
  const _next = () => {
    if (pendingData) {
      const localPendingData = pendingData;
      pendingData = null;
      _handleData(localPendingData);
    }
  };
  ws.onmessage = m => {
    _handleData(m.data);
  };
})();
                ${lt}/code${gt}${lt}/pre${gt}
              ${lt}/body${gt}
            ${lt}/html${gt}
          `);
        } else if (match = req.url.match(/^\/frame\/([0-9]+)$/)) {
          const frameId = parseInt(match[1], 10);
          const frameData = framesData[frameId];
          if (frameData) {
            console.log('send frame data', typeof frameData, frameData.constructor && frameData.constructor.name, frameData && frameData.length);
            res.setHeader('Content-Type', 'application/octet-stream');
            res.end(frameData);
          } else {
            res.statusCode = 404;
            res.end();
          }
        } else {
          res.statusCode = 404;
          res.end();
        }
      });

      const wss = new window.browser.ws.Server({
        server,
      });
      wss.on('connection', (c, request) => {
        console.log('open connection');

        const _onCameraFrame = a => {
          console.log('camera frame', a.length, c.readyState === window.browser.ws.OPEN);
          if (c.readyState === window.browser.ws.OPEN) {
            const updates = a.map((e, i) => {
              const {width, height, bpp, stride, data} = e;
              framesData[i] = Buffer.from(data);
              return {
                index: i,
                width,
                height,
                bpp,
                stride,
              };
            });
            c.send(JSON.stringify(updates));
          }
        };
        window.browser.nativeMl.RequestCamera(_onCameraFrame);

        c.on('close', () => {
          console.log('close connection 1');
          framesData.length = 0;
          console.log('close connection 2');
          window.browser.nativeMl.CancelCamera(_onCameraFrame);
          console.log('close connection 3');
        });
      });

      server.listen(7999, '0.0.0.0', () => {
        console.log('listening');
      });
      server.on('error', err => {
        console.warn('server error', err.stack);
      });
    })();
  </script>
  </body>
</html>
