<html>
  <head>
    <style>
      body {
        margin: 0;
      }
    </style>
  </head>
  <body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/95/three.js"></script>
  <script>
    function init() {
      container = document.createElement('div');
      document.body.appendChild(container);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      // camera.position.set(0, 1, 0);
      camera.lookAt(new THREE.Vector3());

      scene = new THREE.Scene();
      scene.matrixAutoUpdate = false;
      // scene.background = new THREE.Color(0x3B3961);

      const ambientLight = new THREE.AmbientLight(0x808080);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1);
      directionalLight.position.set(1, 1, 1);
      scene.add(directionalLight);

      (() => {
        const geometry = new THREE.BoxBufferGeometry(0.1, 1, 0.1);
        const material = new THREE.MeshPhongMaterial({
          color: 0xE91E63,
        });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.y = 0.5;
        // mesh.position.z = -1;
        mesh.frustumCuled = false;
        scene.add(mesh);
      })();
      (() => {
        const geometry = new THREE.BoxBufferGeometry(0.1, 0.1, 0.1);
        const material = new THREE.MeshPhongMaterial({
          color: 0x4CAF50,
        });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.y = 1 + 0.1;
        // mesh.position.z = -1;
        mesh.frustumCulled = false;
        scene.add(mesh);
      })();

      renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      container.appendChild(renderer.domElement);

      renderer.setAnimationLoop(animate);
    }

    function animate() {
      renderer.render(scene, renderer.vr.enabled ? renderer.vr.getCamera(camera) : camera);
    }

    init();

    // renderer.setAnimationLoop(animate);
    (async () => {
      console.log('request device');
      const display = await navigator.xr.requestDevice();
      console.log('request session');
      const session = await display.requestSession({
        exclusive: true,
      });
      display.session = session;

      console.log('request first frame');
      session.requestAnimationFrame((timestamp, frame) => {
        renderer.vr.setSession(session, {
          frameOfReferenceType: 'stage',
        });

        const viewport = session.baseLayer.getViewport(frame.views[0]);
        const width = viewport.width;
        const height = viewport.height;

        renderer.setSize(width * 2, height);

        renderer.setAnimationLoop(null);

        renderer.vr.enabled = true;
        renderer.vr.setDevice(display);
        renderer.vr.setAnimationLoop(animate);

        console.log('running!');
      });
    })();

    (() => {
      const framesData = [];
    
      const server = window.browser.http.createServer((req, res) => {
        console.log('got request', req.url);
        
        let match;
        if (req.url === '/') {
          res.setHeader('Content-Type', 'text/html');
          const lt = String.fromCodePoint(60);
          const gt = String.fromCodePoint(62);
          res.end(`\
            ${lt}!doctype html${gt}
            ${lt}html${gt}
              ${lt}head${gt}${lt}/head${gt}
              ${lt}body${gt}
                ${lt}canvas id=canvas /${gt}
                ${lt}pre${gt}${lt}code${gt}
(() => {
  const width = 1280;
  const height = 1024;

  const canvas = document.getElementById('canvas');
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext('2d');

  const ws = new WebSocket((window.location.protocol === 'https:' ? 'wss' : 'ws') + '://' + window.location.host + '/');
  ws.binaryType = 'arraybuffer';
  ws.onopen = () => {
    console.log('connected');
  };

  let running = false;
  let pendingData = null;
  const _handleData = data => {
    if (!running) {
      running = true;
      
      const datas = JSON.parse(data);
      Promise.all(datas.map(data =>
        fetch('/frame/' + data.index)
          .then(res => res.arrayBuffer())
          .then(arrayBuffer => ({
            data,
            arrayBuffer,
          }))
      ))
        .then(results => {
          const result = results[0];
          const {data, arrayBuffer} = result;
          const {width, height} = data;
          
          const imageData = ctx.createImageData(width, height);
          imageData.data.set(new Uint8ClampedArray(arrayBuffer).slice(0, imageData.data.byteLength));
          ctx.putImageData(imageData, 0, 0);
        })
        .then(() => {
          running = false;
          _next();
        })
        .catch(err => {
          console.warn(err.stack);
          
          running = false;
          _next();
        });
    } else {
      pendingData = data;
    }
  };
  const _next = () => {
    if (pendingData) {
      const localPendingData = pendingData;
      pendingData = null;
      _handleData(localPendingData);
    }
  };
  ws.onmessage = m => {
    _handleData(m.data);
  };
})();
                ${lt}/code${gt}${lt}/pre${gt}
              ${lt}/body${gt}
            ${lt}/html${gt}
          `);
        } else if (match = req.url.match(/^\/frame\/([0-9]+)$/)) {
          const frameId = parseInt(match[1], 10);
          const frameData = framesData[frameId];
          if (frameData) {
            console.log('send frame data', typeof frameData, frameData.constructor && frameData.constructor.name, frameData && frameData.length);
            res.setHeader('Content-Type', 'application/octet-stream');
            res.end(frameData);
          } else {
            res.statusCode = 404;
            res.end();
          }
        } else {
          res.statusCode = 404;
          res.end();
        }
      });

      const wss = new window.browser.ws.Server({
        server,
      });
      wss.on('connection', (c, request) => {
        console.log('open connection');

        const _onCameraFrame = a => {
          console.log('camera frame', a.length, c.readyState === window.browser.ws.OPEN);
          if (c.readyState === window.browser.ws.OPEN) {
            const updates = a.map((e, i) => {
              const {width, height, bpp, stride, data} = e;
              framesData[i] = Buffer.from(data);
              return {
                index: i,
                width,
                height,
                bpp,
                stride,
              };
            });
            c.send(JSON.stringify(updates));
          }
        };
        window.browser.nativeMl.RequestCamera(_onCameraFrame);

        c.on('close', () => {
          console.log('close connection 1');
          framesData.length = 0;
          console.log('close connection 2');
          window.browser.nativeMl.CancelCamera(_onCameraFrame);
          console.log('close connection 3');
        });
      });
      
      server.listen(7999, '0.0.0.0', () => {
        console.log('listening');
      });
      server.on('error', err => {
        console.warn('server error', err.stack);
      });
    })();
  </script>
  </body>
</html>
